import 'dart:async';

import 'package:easy_localization/easy_localization.dart';
import 'package:flutter/material.dart';
import 'package:mobile/app/core/extensions/log_extension.dart';
import 'package:mobile/app/core/helpers/helper_functions.dart';
import 'package:mobile/app/core/helpers/pref_keys.dart';
import 'package:mobile/app/core/injection/injection.dart';
import 'package:mobile/app/core/router/values.dart';
import 'package:mobile/app/theme/theme.dart';
import 'package:mobile/features/common/presentation/cubit/enable_location_cubit.dart';
import 'package:mobile/features/common/presentation/services/image_retry_service.dart';
import 'package:mobile/features/common/presentation/views/base_scaffold.dart';
import 'package:mobile/features/common/presentation/widgets/hmp_custom_button.dart';
import 'package:mobile/features/common/presentation/widgets/horizontal_space.dart';
import 'package:mobile/features/common/presentation/widgets/rounded_button_with_border.dart';
import 'package:mobile/features/onboarding/presentation/widgets/page_pop_view.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_first.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_second.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_third.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_fourth.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_fifth.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_wallet_exists.dart';
import 'package:mobile/features/onboarding/presentation/widgets/onboarding_page_profile_exists.dart';
import 'package:mobile/features/onboarding/presentation/widgets/test_onboarding_widget.dart';
import 'package:wepin_flutter_widget_sdk/wepin_flutter_widget_sdk_type.dart';
import 'package:mobile/features/my/presentation/cubit/profile_cubit.dart';
import 'package:mobile/features/my/infrastructure/dtos/update_profile_request_dto.dart';
import 'package:mobile/features/onboarding/presentation/widgets/gradient_button.dart';
import 'package:mobile/features/onboarding/models/character_profile.dart';
import 'package:mobile/features/onboarding/services/character_image_service.dart';
import 'package:mobile/features/onboarding/services/image_upload_service.dart';
import 'package:mobile/generated/locale_keys.g.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:mobile/app/core/constants/storage.dart';
import 'package:mobile/features/wepin/cubit/wepin_cubit.dart';
import 'package:mobile/features/wallets/presentation/cubit/wallets_cubit.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:mobile/app/core/storage/secure_storage.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:mobile/app/core/cubit/base_cubit.dart';
import 'package:mobile/features/nft/domain/repositories/nft_repository.dart';
import 'package:mobile/features/nft/infrastructure/dtos/mint_nft_request_dto.dart';
import 'package:mobile/app/core/env/app_env.dart';

/// OnBoardingScreen is a stateful widget that represents the onboarding screen.
///
/// It is responsible for displaying the onboarding slides to the user.
/// The widget is implemented using the stateful widget pattern where the
/// state is managed by the [_OnBoardingScreenState] class.
class OnBoardingScreen extends StatefulWidget {
  /// Creates a new instance of [OnBoardingScreen].
  ///
  /// The [key] parameter is used to uniquely identify the widget throughout the
  /// widget tree.
  const OnBoardingScreen({super.key});

  /// Pushes the [OnBoardingScreen] widget to the navigation stack.
  ///
  /// This method takes a [BuildContext] as a parameter and returns a [Future]
  /// that resolves to the result of the navigation. The widget is wrapped in a
  /// [MaterialPageRoute] and pushed onto the navigation stack using the
  /// [Navigator.push] method.
  static Future<T?> push<T extends Object?>(BuildContext context) async {
    return await Navigator.push<T>(
      context,
      MaterialPageRoute(
        builder: (_) => const OnBoardingScreen(),
      ),
    );
  }

  /// Creates the mutable state for this widget at a given location in the tree.
  ///
  /// This method is called when inflating the widget's element, and should
  /// return a new instance of the associated [State] class.
  ///
  /// Subclasses should override this method to return a newly created
  /// instance of their associated [State] subclass.
  ///
  /// The framework will call this method multiple times over the lifetime of
  /// a [StatefulWidget], for example when the widget is inserted into the
  /// tree, when the widget is updated, or when the widget is removed from the
  /// tree. It is therefore critical that the [createState] method return
  /// consistently distinct objects.
  @override
  State<OnBoardingScreen> createState() => _OnBoardingScreenState();
}

class _OnBoardingScreenState extends State<OnBoardingScreen> {
  var currentSlideIndex = 0;
  bool dontShowCheckBox = false;
  bool _isConfirming = false;
  bool _isCheckingWallet = false; // Add wallet checking state
  bool _hasExistingWallet = false; // Track if user has existing wallet
  bool _hasExistingProfile = false; // Track if user has existing profile parts
  bool _hasExistingNickname = false; // Track if user has existing nickname
  bool _isWepinInitialized = false; // Track if Wepin SDK is initialized
  String selectedProfile = '';
  CharacterProfile? selectedCharacter;
  String nickname = '';
  bool _debugMode = false; // Debug mode flag
  // to prevent double tap while in process to check location and navigate

  @override
  void initState() {
    super.initState();
    
    // New onboarding screens (2 new + 2 existing)
    // Total 4 screens now

    // call function to check if location is enabled with error handling
    try {
      getIt<EnableLocationCubit>().checkLocationEnabled();
    } catch (e) {
      '‚ùå Error checking location: $e'.log();
    }
    
    // Load saved onboarding state
    _loadOnboardingState();
  }
  
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    
    // Initialize Wepin SDK only once when dependencies are ready
    if (!_isWepinInitialized) {
      _isWepinInitialized = true;
      _initializeWepin();
    }
  }

  Future<void> _initializeWepin() async {
    try {
      'üîß Initializing Wepin SDK for onboarding...'.log();
      'üì± Current onboarding step: $currentSlideIndex'.log();
      
      final wepinCubit = getIt<WepinCubit>();
      
      // Initialize Wepin SDK with current language
      await wepinCubit.initializeWepinSDK(
        selectedLanguageCode: context.locale.languageCode,
      );
      
      '‚úÖ Wepin SDK initialized successfully'.log();
      
      // Check for existing WePIN wallet after SDK is ready
      await _checkExistingWepinWallet();
    } catch (e) {
      '‚ùå Failed to initialize Wepin SDK: $e'.log();
    }
  }
  
  Future<void> _checkExistingWepinWallet() async {
    try {
      'üîç Checking for existing WePIN wallet...'.log();
      
      final wepinCubit = getIt<WepinCubit>();
      if (wepinCubit.state.wepinWidgetSDK == null) {
        '‚ö†Ô∏è WePIN SDK not initialized for wallet check'.log();
        return;
      }
      
      // Check if user is registered with WePIN and has actual wallet
      bool isRegistered = false;
      bool hasActualWallet = false;
      
      try {
        // Try to get current user to check if registered
        final currentUser = await wepinCubit.state.wepinWidgetSDK!.login.getCurrentWepinUser();
        isRegistered = (currentUser != null && currentUser.userInfo != null);
        'üîç WePIN user check: ${isRegistered ? "Existing user found" : "No user found"}'.log();
        
        if (isRegistered && currentUser!.userInfo != null) {
          'üìß Existing user email: ${currentUser.userInfo!.email}'.log();
          
          // Check if user has actual wallet addresses
          final walletsCubit = getIt<WalletsCubit>();
          await walletsCubit.onGetAllWallets();
          'üíº Connected wallets count: ${walletsCubit.state.connectedWallets.length}'.log();
          
          if (walletsCubit.state.connectedWallets.isNotEmpty) {
            // Check for Ethereum wallet specifically
            try {
              final ethereumWallet = walletsCubit.state.connectedWallets.firstWhere(
                (wallet) => wallet.provider.toLowerCase() == 'ethereum',
                orElse: () => walletsCubit.state.connectedWallets.first,
              );
              'üíº Found wallet: ${ethereumWallet.provider} - ${ethereumWallet.publicAddress}'.log();
              hasActualWallet = true;
            } catch (e) {
              '‚ö†Ô∏è Error finding wallet: $e'.log();
              hasActualWallet = false;
            }
          } else {
            '‚ö†Ô∏è WePIN user exists but no wallet addresses found'.log();
            hasActualWallet = false;
          }
        }
      } catch (e) {
        '‚ö†Ô∏è Error checking WePIN user: $e'.log();
      }
      
      if (isRegistered && hasActualWallet) {
        '‚úÖ Existing WePIN user with wallet detected'.log();
        
        // Try to get the current status
        final status = await wepinCubit.state.wepinWidgetSDK!.getStatus();
        'üìä Current WePIN status: $status'.log();
        
        // User has both WePIN account and wallet address
        setState(() {
          _hasExistingWallet = true;
        });
        
        // Optionally try to login silently
        if (status == WepinLifeCycle.initialized) {
          try {
            'üîê Attempting silent login for existing user...'.log();
            // This would need to be implemented based on stored credentials
            // For now, just mark that wallet exists
          } catch (e) {
            '‚ö†Ô∏è Silent login failed: $e'.log();
          }
        }
      } else if (isRegistered && !hasActualWallet) {
        '‚ö†Ô∏è WePIN user exists but no wallet - need to create wallet'.log();
        setState(() {
          _hasExistingWallet = false;
        });
      } else {
        'üÜï New WePIN user - will need to create account and wallet'.log();
        setState(() {
          _hasExistingWallet = false;
        });
      }
    } catch (e) {
      '‚ùå Error checking existing WePIN wallet: $e'.log();
    }
  }
  
  Future<void> _checkUserProfile() async {
    try {
      'üîç Checking for existing user profile...'.log();

      // Get user profile to check for existing profile parts
      final profileCubit = getIt<ProfileCubit>();
      await profileCubit.onGetUserProfile();
      final userProfile = profileCubit.state.userProfileEntity;

      bool hasValidProfile = false;

      if (userProfile != null) {
        // Check if we have profile parts string
        if (userProfile.profilePartsString != null && userProfile.profilePartsString!.isNotEmpty) {
          '‚úÖ Profile parts exist: ${userProfile.profilePartsString!.length} characters'.log();
          hasValidProfile = true;
        }

        // Check if we have a valid final profile image URL
        if (!hasValidProfile &&
            userProfile.finalProfileImageUrl != null &&
            userProfile.finalProfileImageUrl!.isNotEmpty) {
          'üîç Checking if profile image URL is valid...'.log();
          '   - URL: ${userProfile.finalProfileImageUrl}'.log();

          // Validate that the image URL actually has valid data
          final isValidImage = await _validateImageUrl(userProfile.finalProfileImageUrl!);

          if (isValidImage) {
            '‚úÖ Profile image URL is valid and accessible'.log();
            hasValidProfile = true;
          } else {
            '‚ö†Ô∏è Profile image URL exists but image is not ready/valid'.log();
            '   - Treating as no profile (new user)'.log();
          }
        }

        if (hasValidProfile) {
          '‚úÖ Valid profile found - skipping character selection'.log();
          '   - ProfileParts: ${userProfile.profilePartsString?.isNotEmpty ?? false}'.log();
          '   - ValidImage: ${hasValidProfile}'.log();

          // Check if user has a nickname
          final hasNickname = userProfile.nickName.isNotEmpty;
          '   - Nickname: ${hasNickname ? userProfile.nickName : "ÏóÜÏùå"}'.log();

          setState(() {
            _hasExistingProfile = true;
            _hasExistingNickname = hasNickname;
          });
        } else {
          'üÜï No valid profile found - character selection needed'.log();
          setState(() {
            _hasExistingProfile = false;
            _hasExistingNickname = false;
          });
        }
      } else {
        'üÜï No user profile - character selection needed'.log();
        setState(() {
          _hasExistingProfile = false;
          _hasExistingNickname = false;
        });
      }
    } catch (e) {
      '‚ùå Error checking user profile: $e'.log();
      setState(() {
        _hasExistingProfile = false;
        _hasExistingNickname = false;
      });
    }
  }

  /// Validate if an image URL actually contains valid image data
  /// Uses retry logic to handle server-side image generation delays
  Future<bool> _validateImageUrl(String imageUrl) async {
    try {
      // Don't validate empty URLs
      if (imageUrl.isEmpty) return false;

      'üîç Starting image validation with retry logic for: $imageUrl'.log();

      // Use the ImageRetryService with fast onboarding mode
      final isValid = await ImageRetryService.validateImageWithRetry(imageUrl, isOnboarding: true);

      if (isValid) {
        '‚úÖ Image validated successfully after retries'.log();
      } else {
        '‚ùå Image validation failed after all retries'.log();
      }

      return isValid;
    } catch (e) {
      'Error validating image URL: $e'.log();
      return false;
    }
  }

  Future<void> _loadOnboardingState() async {
    final prefs = await SharedPreferences.getInstance();
    
    // Check debug mode
    //_debugMode = prefs.getBool(StorageValues.onboardingDebugMode) ?? false;
    
    // Always load saved step regardless of debug mode
    final savedStep = prefs.getInt(StorageValues.onboardingCurrentStep) ?? 0;
    
    // If there's a saved step > 0, show resume popup
    if (savedStep > 0 && mounted) {
      'üì± Ï†ÄÏû•Îêú Ïò®Î≥¥Îî© Îã®Í≥Ñ Î∞úÍ≤¨: $savedStep'.log();
      _showResumePopup(savedStep);
    } else {
      setState(() {
        currentSlideIndex = savedStep;
      });
    }
    
    if (_debugMode) {
      'üêõ ÎîîÎ≤ÑÍ∑∏ Î™®Îìú ÌôúÏÑ±Ìôî - Ïò®Î≥¥Îî© ÌëúÏãú (Ï†ÄÏû•Îêú Îã®Í≥Ñ: $savedStep)'.log();
    } else {
      'üì± Ïò®Î≥¥Îî© ÏÉÅÌÉú Î≥µÏõê: Ïä§ÌÖù $savedStep'.log();
    }
  }
  
  Future<void> _showResumePopup(int savedStep) async {
    await showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return Dialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20),
          ),
          backgroundColor: Colors.white,
          child: Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(20),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  LocaleKeys.onboarding_continue_process.tr(),
                  style: TextStyle(
                    fontFamily: 'LINESeedKR',
                    fontSize: 20,
                    fontWeight: FontWeight.w700,
                    color: Colors.black87,
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  LocaleKeys.onboarding_previous_process_found.tr(),
                  style: TextStyle(
                    fontFamily: 'LINESeedKR',
                    fontSize: 14,
                    fontWeight: FontWeight.w400,
                    color: Colors.black87,
                    height: 1.4,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 24),
                SizedBox(
                  width: double.infinity,
                  child: GradientButton(
                    text: 'ÌôïÏù∏ÌñàÏñ¥!',
                    onPressed: () {
                      Navigator.of(context).pop();
                      setState(() {
                        currentSlideIndex = savedStep;
                      });
                    },
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  Future<void> _saveCurrentStep() async {
    // Don't save if we're on the final page or if onboarding is completed
    if (currentSlideIndex >= 4) {
      '‚è≠Ô∏è ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ - ÏÉÅÌÉú Ï†ÄÏû• Í±¥ÎÑàÎõ∞Í∏∞'.log();
      return;
    }

    final prefs = await SharedPreferences.getInstance();

    // Check if onboarding is already completed
    final isCompleted = prefs.getBool(StorageValues.onboardingCompleted) ?? false;
    if (isCompleted) {
      '‚úÖ Ïò®Î≥¥Îî© Ïù¥ÎØ∏ ÏôÑÎ£åÎê® - ÏÉÅÌÉú Ï†ÄÏû• Í±¥ÎÑàÎõ∞Í∏∞'.log();
      return;
    }

    // Always save current step regardless of debug mode
    await prefs.setInt(StorageValues.onboardingCurrentStep, currentSlideIndex);
    'üíæ Ïò®Î≥¥Îî© ÏßÑÌñâ ÏÉÅÌÉú Ï†ÄÏû•: Ïä§ÌÖù $currentSlideIndex'.log();
  }

  void _goToNextPage() async {
    // Hide keyboard if visible
    FocusScope.of(context).unfocus();
    
    if (currentSlideIndex == 0) {
      'üöÄ Ï≤´ Î≤àÏß∏ Ïò®Î≥¥Îî© ÌôîÎ©¥ÏóêÏÑú Îã§Ïùå Î≤ÑÌäº ÌÅ¥Î¶≠'.log();
      
      // First page - check for Ethereum wallet
      bool hasWallet = await _checkEthereumWallet();
      
      setState(() {
        _hasExistingWallet = hasWallet;
      });
      
      if (hasWallet) {
        '‚úÖ ÏßÄÍ∞ëÏù¥ ÏûàÏùå - ÏßÄÍ∞ë ÏûàÏùå ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô'.log();
        // Show wallet exists page
        _moveToPage(1);
      } else {
        '‚ùå ÏßÄÍ∞ëÏù¥ ÏóÜÏùå - ÏßÄÍ∞ë ÏÉùÏÑ± ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô'.log();
        // No wallet, go to wallet creation page
        _moveToPage(1);
      }
    } else if (currentSlideIndex == 1) {
      // From wallet page, check if user has existing profile
      await _checkUserProfile();

      if (_hasExistingWallet) {
        // User has existing wallet
        if (_hasExistingProfile) {
          'üÜó ÌîÑÎ°úÌïÑ ÌååÏ∏† ÏûàÏùå - ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô'.log();
          _moveToPage(2); // Show profile exists page
        } else {
          'üÜï ÌîÑÎ°úÌïÑ ÌååÏ∏† ÏóÜÏùå - Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô'.log();
          _moveToPage(2); // Go to character selection
        }
      } else {
        // Just created wallet, check profile
        if (_hasExistingProfile) {
          'üÜó ÏÉà ÏßÄÍ∞ë ÏÉùÏÑ± + ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ - ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ ÌôîÎ©¥ÏúºÎ°ú'.log();
          _moveToPage(2); // Show profile exists page
        } else {
          'üÜï ÏÉà ÏßÄÍ∞ë ÏÉùÏÑ± + ÌîÑÎ°úÌïÑ ÏóÜÏùå - Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉùÏúºÎ°ú'.log();
          _moveToPage(2); // Go to character selection
        }
      }
    } else if (currentSlideIndex == 2 && _hasExistingProfile) {
      // From profile exists page, check if user has nickname
      if (_hasExistingNickname) {
        // User has both profile and nickname, skip to final page
        '‚úÖ ÌîÑÎ°úÌïÑÍ≥º ÎãâÎÑ§ÏûÑ Î™®Îëê ÏûàÏùå - ÏôÑÎ£å ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô'.log();
        _moveToPage(4); // Skip nickname input, go to final page
      } else {
        // User has profile but no nickname, go to nickname input
        '‚ö†Ô∏è ÌîÑÎ°úÌïÑÏùÄ ÏûàÏßÄÎßå ÎãâÎÑ§ÏûÑ ÏóÜÏùå - ÎãâÎÑ§ÏûÑ ÏûÖÎ†• ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô'.log();
        _moveToPage(3); // Go to nickname input page
      }
    } else if (currentSlideIndex < 4) {
      _moveToPage(currentSlideIndex + 1);
    }
  }
  
  void _moveToPage(int pageIndex) {
    setState(() {
      currentSlideIndex = pageIndex;
    });
    // Save state immediately when entering new page
    _saveCurrentStep();
    'üìç Ïò®Î≥¥Îî© ÌéòÏù¥ÏßÄ Ïù¥Îèô: $pageIndex'.log();
  }
  
  Future<bool> _checkEthereumWallet() async {
    try {
      // Check if Wepin SDK is initialized
      final wepinCubit = getIt<WepinCubit>();
      if (wepinCubit.state.wepinWidgetSDK == null) {
        '‚ùå Wepin SDK is not initialized'.log();
        return false;
      }
      
      // Check Wepin status
      final status = await wepinCubit.state.wepinWidgetSDK!.getStatus();
      'üìä Wepin status: $status'.log();
      
      // If not logged in, try to login first
      if (status == WepinLifeCycle.initialized) {
        'üîÑ Wepin initialized but not logged in, attempting login...'.log();
        await wepinCubit.loginSocialAuthProvider();
        
        // Check status again after login attempt
        final newStatus = await wepinCubit.state.wepinWidgetSDK!.getStatus();
        'üìä Wepin status after login attempt: $newStatus'.log();
        
        if (newStatus != WepinLifeCycle.login) {
          '‚ùå Failed to login to Wepin'.log();
          return false;
        }
      } else if (status != WepinLifeCycle.login) {
        '‚ùå Wepin is not in login state and cannot proceed'.log();
        return false;
      }
      
      // Get accounts and check for Ethereum wallet
      final accounts = await wepinCubit.state.wepinWidgetSDK!.getAccounts();
      'üìã Total accounts found: ${accounts.length}'.log();
      
      // Log all accounts
      for (var account in accounts) {
        'üí≥ Account - Network: ${account.network}, Address: ${account.address}'.log();
      }
      
      // Check for Ethereum accounts
      final ethereumAccounts = accounts.where((account) => 
        account.network.toLowerCase() == 'ethereum'
      ).toList();
      
      if (ethereumAccounts.isNotEmpty) {
        '‚úÖ Found ${ethereumAccounts.length} Ethereum wallet(s)'.log();
        for (var eth in ethereumAccounts) {
          'üî∑ Ethereum Address: ${eth.address}'.log();
        }
        return true;
      } else {
        '‚ùå No Ethereum wallet found'.log();
        return false;
      }
    } catch (e) {
      '‚ùå Error checking Ethereum wallet: $e'.log();
      return false;
    }
  }
  
  Future<void> _createWepinWallet() async {
    'üéØ ÏßÄÍ∞ë ÏÉùÏÑ± Î≤ÑÌäº ÌÅ¥Î¶≠Îê®!'.log();
    
    try {
      final wepinCubit = getIt<WepinCubit>();
      
      // Check if SDK is initialized
      if (wepinCubit.state.wepinWidgetSDK == null) {
        '‚ùå Wepin SDK not initialized for wallet creation'.log();
        'üîÑ Attempting to initialize Wepin SDK now...'.log();
        
        // Try to initialize SDK if not already done
        await wepinCubit.initializeWepinSDK(
          selectedLanguageCode: context.locale.languageCode,
        );
        
        // Check again after initialization
        if (wepinCubit.state.wepinWidgetSDK == null) {
          '‚ùå Failed to initialize Wepin SDK'.log();
          return;
        }
      }
      
      // Get current status
      var status = await wepinCubit.state.wepinWidgetSDK!.getStatus();
      'üîÑ Wepin status before wallet creation: $status'.log();
      
      // Show loading
      setState(() {
        _isConfirming = true;
      });
      
      // Check if user is already registered with WePIN
      bool isRegistered = false;
      try {
        // Try to get current user to check if registered
        final currentUser = await wepinCubit.state.wepinWidgetSDK!.login.getCurrentWepinUser();
        isRegistered = (currentUser != null && currentUser.userInfo != null);
        'üîç WePIN user check: ${isRegistered ? "Existing user found" : "No user found"}'.log();
        if (isRegistered && currentUser!.userInfo != null) {
          'üìß Existing user email: ${currentUser.userInfo!.email}'.log();
        }
      } catch (e) {
        '‚ö†Ô∏è Error checking WePIN user: $e'.log();
      }
      
      // If only initialized, need to login first using the new flow
      if (status == WepinLifeCycle.initialized) {
        'üîÑ Wepin SDK initialized, performing login flow...'.log();
        
        try {
          // Get stored social login tokens
          await wepinCubit.getSocialLoginValues();
          
          // Check if we have tokens for login
          final socialType = wepinCubit.state.socialTokenIsAppleOrGoogle;
          String? idToken;
          
          if (socialType == 'GOOGLE') {
            idToken = wepinCubit.state.googleAccessToken;
            'üîë Using Google ID token for Wepin login'.log();
          } else if (socialType == 'APPLE') {
            idToken = wepinCubit.state.appleIdToken;
            'üîë Using Apple ID token for Wepin login'.log();
          }
          
          if (idToken == null || idToken.isEmpty) {
            '‚ùå No ID token available for Wepin login'.log();
            
            // Fallback: Open widget for OAuth login
            'üì± Opening Wepin widget for OAuth login...'.log();
            setState(() {
              _isConfirming = false;
            });
            
            // Start polling for wallet creation with onboarding flag
            wepinCubit.startWalletCheckTimer(isFromOnboarding: true);
            
            // Open widget which will show login UI
            await wepinCubit.openWepinWidget(context);
            
            'üì± Wepin widget closed - polling continues in background'.log();
            
            // After WePIN OAuth login, check user status and save tokens
            await _checkAndSaveWepinUser();
            await _saveWepinTokensAfterOAuth();
            
            return; // Exit here as polling will handle wallet detection
          }
          
          // Perform login with ID token using the new flow
          'üìç Performing Wepin login with ID token...'.log();
          await wepinCubit.loginSocialAuthProvider();
          
          // Check if login was successful
          status = await wepinCubit.state.wepinWidgetSDK!.getStatus();
          'üìä Wepin status after login: $status'.log();
          
          if (status != WepinLifeCycle.login) {
            '‚ùå Login failed, opening widget for manual login'.log();
            
            setState(() {
              _isConfirming = false;
            });
            
            // Start polling and open widget
            wepinCubit.startWalletCheckTimer(isFromOnboarding: true);
            await wepinCubit.openWepinWidget(context);
            
            await _checkAndSaveWepinUser();
            await _saveWepinTokensAfterOAuth();
            
            return;
          }
          
          '‚úÖ Login successful, proceeding to wallet creation'.log();
          // Continue to registration/wallet creation below
        } catch (e) {
          '‚ùå Error during login flow: $e'.log();
          wepinCubit.stopWalletCheckTimer(); // Stop polling on error
          setState(() {
            _isConfirming = false;
          });
          return;
        }
      }
      
      // Handle based on WePIN status
      if (status == WepinLifeCycle.login) {
        'üîç Already logged in, checking existing wallets...'.log();
        
        // User is already logged in, check if they have wallets
        final accounts = await wepinCubit.state.wepinWidgetSDK!.getAccounts();
        'üìã Existing accounts: ${accounts.length}'.log();
        
        if (accounts.isNotEmpty) {
          // User already has wallets
          for (var account in accounts) {
            'üí≥ Existing - Network: ${account.network}, Address: ${account.address}'.log();
          }
          
          final ethereumAccounts = accounts.where((account) => 
            account.network.toLowerCase() == 'ethereum'
          ).toList();
          
          if (ethereumAccounts.isNotEmpty) {
            '‚úÖ Ethereum wallet already exists!'.log();
            
            // Save wallets to backend (in case not saved)
            await wepinCubit.saveWalletsToHMPBackend(accounts);
            
            // User has wallet, check profile before moving to next page
            setState(() {
              _isConfirming = false;
              _hasExistingWallet = true;
            });
            await _checkUserProfile();
            if (_hasExistingProfile) {
              'üÜó ÏßÄÍ∞ë ÏÉùÏÑ± ÏôÑÎ£å + ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ - ÌîÑÎ°úÌïÑ ÌôîÎ©¥ÏúºÎ°ú'.log();
              _moveToPage(2); // Show profile exists page
            } else {
              'üÜï ÏßÄÍ∞ë ÏÉùÏÑ± ÏôÑÎ£å + ÌîÑÎ°úÌïÑ ÏóÜÏùå - Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉùÏúºÎ°ú'.log();
              _moveToPage(2); // Move to character selection
            }
          } else {
            '‚ö†Ô∏è Has wallets but no Ethereum wallet'.log();
            // May need to create Ethereum wallet specifically
            setState(() {
              _isConfirming = false;
            });
          }
        } else {
          '‚ö†Ô∏è Logged in but no wallets found - may need finalize'.log();
          
          // Try to finalize wallet creation
          try {
            'üîÑ Attempting to finalize wallet creation...'.log();
            await wepinCubit.state.wepinWidgetSDK!.finalize();
            
            // Check accounts again
            final newAccounts = await wepinCubit.state.wepinWidgetSDK!.getAccounts();
            if (newAccounts.isNotEmpty) {
              '‚úÖ Wallets created after finalize'.log();
              await wepinCubit.saveWalletsToHMPBackend(newAccounts);
              setState(() {
                _isConfirming = false;
              });
              await _checkUserProfile();
              if (_hasExistingProfile) {
                'üÜó ÏßÄÍ∞ë finalize ÏôÑÎ£å + ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ - ÌîÑÎ°úÌïÑ ÌôîÎ©¥ÏúºÎ°ú'.log();
                _moveToPage(2); // Show profile exists page
              } else {
                'üÜï ÏßÄÍ∞ë finalize ÏôÑÎ£å + ÌîÑÎ°úÌïÑ ÏóÜÏùå - Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉùÏúºÎ°ú'.log();
                _moveToPage(2); // Move to character selection
              }
            } else {
              '‚ùå Still no wallets after finalize'.log();
              setState(() {
                _isConfirming = false;
              });
            }
          } catch (e) {
            '‚ùå Error during finalize: $e'.log();
            setState(() {
              _isConfirming = false;
            });
          }
        }
        
        // Check user status and save tokens
        await _checkAndSaveWepinUser();
        await _saveWepinTokensAfterOAuth();
        
      } else if (status == WepinLifeCycle.loginBeforeRegister) {
        'üöÄ Starting Wepin registration for new user...'.log();
        
        // New user needs registration
        await wepinCubit.state.wepinWidgetSDK!.register(context);
        
        // After registration, check user status and save tokens
        await _checkAndSaveWepinUser();
        await _saveWepinTokensAfterOAuth();
        
        // Wait a moment for wallet creation
        await Future.delayed(const Duration(seconds: 1));
        
        // Check if wallet was created successfully
        final accounts = await wepinCubit.state.wepinWidgetSDK!.getAccounts();
        'üìã Accounts after registration: ${accounts.length}'.log();
        
        // Log all created accounts
        for (var account in accounts) {
          'üí≥ Created - Network: ${account.network}, Address: ${account.address}'.log();
        }
        
        final ethereumAccounts = accounts.where((account) => 
          account.network.toLowerCase() == 'ethereum'
        ).toList();
        
        if (ethereumAccounts.isNotEmpty) {
          '‚úÖ Ethereum wallet created successfully!'.log();
          for (var eth in ethereumAccounts) {
            'üî∑ New Ethereum Address: ${eth.address}'.log();
          }
          
          // Save wallets to backend
          await wepinCubit.saveWalletsToHMPBackend(accounts);
          
          // Wallet created successfully, check profile before moving
          setState(() {
            _isConfirming = false;
          });
          await _checkUserProfile();
          if (_hasExistingProfile) {
            'üÜó ÏÉà ÏßÄÍ∞ë ÏÉùÏÑ± + ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ - ÌîÑÎ°úÌïÑ ÌôîÎ©¥ÏúºÎ°ú'.log();
            _moveToPage(2); // Show profile exists page
          } else {
            'üÜï ÏÉà ÏßÄÍ∞ë ÏÉùÏÑ± + ÌîÑÎ°úÌïÑ ÏóÜÏùå - Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉùÏúºÎ°ú'.log();
            _moveToPage(2); // Move to character selection
          }
        } else {
          '‚ùå No Ethereum wallet created'.log();
          setState(() {
            _isConfirming = false;
          });
        }
      } else {
        setState(() {
          _isConfirming = false;
        });
        '‚ùå Wepin not in correct state for wallet creation: $status'.log();
      }
    } catch (e) {
      setState(() {
        _isConfirming = false;
      });
      '‚ùå Error creating Wepin wallet: $e'.log();
    }
  }

  Future<void> _checkAndSaveWepinUser() async {
    try {
      'üîç WePIN ÏÇ¨Ïö©Ïûê ÏÉÅÌÉú ÌôïÏù∏ Ï§ë...'.log();
      
      final wepinCubit = getIt<WepinCubit>();
      if (wepinCubit.state.wepinWidgetSDK == null) {
        '‚ùå WePIN SDK not initialized'.log();
        return;
      }
      
      // ÌòÑÏû¨ WePIN ÏÇ¨Ïö©Ïûê ÌôïÏù∏
      try {
        final currentUser = await wepinCubit.state.wepinWidgetSDK!.login.getCurrentWepinUser();
        
        if (currentUser != null && currentUser.userInfo != null) {
          '‚úÖ WePIN ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏ ÌôïÏù∏: ${currentUser.userInfo!.email}'.log();
          'üìä Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú: ${currentUser.userStatus?.loginStatus}'.log();
          'üìä Provider: ${currentUser.userInfo!.provider}'.log();
          
          // Î°úÍ∑∏Ïù∏ ÏÉÅÌÉúÎ•º SharedPreferencesÏóê Ï†ÄÏû•
          final prefs = await SharedPreferences.getInstance();
          await prefs.setBool('wepin_logged_in', true);
          await prefs.setString('wepin_user_email', currentUser.userInfo!.email);
          await prefs.setString('wepin_user_provider', currentUser.userInfo!.provider ?? '');
          
          '‚úÖ WePIN Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ÄÏû• ÏôÑÎ£å'.log();
        } else {
          '‚ö†Ô∏è WePIN ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÜÏùå'.log();
          await _clearWepinLoginState();
        }
      } catch (e) {
        '‚ùå getCurrentWepinUser ÏóêÎü¨: $e'.log();
        
        // InvalidLoginSession Ïò§Î•ò Ï≤òÎ¶¨
        if (e.toString().contains('InvalidLoginSession')) {
          'üîÑ InvalidLoginSession Í∞êÏßÄ - ÏÑ∏ÏÖò Î≥µÍµ¨ ÏãúÎèÑ'.log();
          await _handleInvalidLoginSession(wepinCubit);
        } else {
          // Îã§Î•∏ Ïò§Î•òÏùò Í≤ΩÏö∞ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ïÎ¶¨
          await _clearWepinLoginState();
        }
      }
    } catch (e) {
      '‚ùå _checkAndSaveWepinUser ÏóêÎü¨: $e'.log();
      await _clearWepinLoginState();
    }
  }

  /// InvalidLoginSession Ïò§Î•ò Ï≤òÎ¶¨ Î∞è ÏÑ∏ÏÖò Î≥µÍµ¨
  Future<void> _handleInvalidLoginSession(WepinCubit wepinCubit) async {
    try {
      'üîÑ ÏÑ∏ÏÖò Î≥µÍµ¨ ÌîÑÎ°úÏÑ∏Ïä§ ÏãúÏûë...'.log();
      
      // 1. ÌòÑÏû¨ Wepin ÏÉÅÌÉú ÌôïÏù∏
      final currentStatus = await wepinCubit.state.wepinWidgetSDK!.getStatus();
      'üìä ÌòÑÏû¨ Wepin ÏÉÅÌÉú: $currentStatus'.log();
      
      // 2. ÏÑ∏ÏÖò Ï†ïÎ¶¨ - Wepin Î°úÍ∑∏ÏïÑÏõÉ ÏãúÎèÑ
      try {
        'üßπ Wepin ÏÑ∏ÏÖò Ï†ïÎ¶¨ ÏãúÎèÑ...'.log();
        await wepinCubit.state.wepinWidgetSDK!.login.logoutWepin();
        '‚úÖ Wepin Î°úÍ∑∏ÏïÑÏõÉ ÏôÑÎ£å'.log();
      } catch (logoutError) {
        '‚ö†Ô∏è Wepin Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå® (Î¨¥Ïãú Í∞ÄÎä•): $logoutError'.log();
      }
      
      // 3. ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      final newStatus = await wepinCubit.state.wepinWidgetSDK!.getStatus();
      wepinCubit.updateWepinStatus(newStatus);
      'üìä Ï†ïÎ¶¨ ÌõÑ Wepin ÏÉÅÌÉú: $newStatus'.log();
      
      // 4. Î°úÏª¨ ÏÉÅÌÉú Ï†ïÎ¶¨
      await _clearWepinLoginState();
      
      // 5. ÏÜåÏÖú Î°úÍ∑∏Ïù∏ ÌÜ†ÌÅ∞ ÏÉàÎ°úÍ≥†Ïπ® ÏãúÎèÑ
      'üîÑ ÏÜåÏÖú Î°úÍ∑∏Ïù∏ ÌÜ†ÌÅ∞ ÏÉàÎ°úÍ≥†Ïπ® ÏãúÎèÑ...'.log();
      await wepinCubit.getSocialLoginValues();
      
      // 6. ÌÜ†ÌÅ∞Ïù¥ ÏûàÏúºÎ©¥ ÏûêÎèô Ïû¨Î°úÍ∑∏Ïù∏ ÏãúÎèÑ
      final hasValidToken = (wepinCubit.state.socialTokenIsAppleOrGoogle == 'GOOGLE' && 
                            wepinCubit.state.googleAccessToken?.isNotEmpty == true) ||
                           (wepinCubit.state.socialTokenIsAppleOrGoogle == 'APPLE' && 
                            wepinCubit.state.appleIdToken?.isNotEmpty == true);
                            
      if (hasValidToken) {
        'üîÑ Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞ Î∞úÍ≤¨ - ÏûêÎèô Ïû¨Î°úÍ∑∏Ïù∏ ÏãúÎèÑ...'.log();
        
        try {
          await wepinCubit.loginSocialAuthProvider();
          
          // Ïû¨Î°úÍ∑∏Ïù∏ ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
          final recoveredStatus = await wepinCubit.state.wepinWidgetSDK!.getStatus();
          'üìä Î≥µÍµ¨ ÌõÑ Wepin ÏÉÅÌÉú: $recoveredStatus'.log();
          
          if (recoveredStatus == WepinLifeCycle.login) {
            '‚úÖ ÏÑ∏ÏÖò Î≥µÍµ¨ ÏÑ±Í≥µ'.log();
            
            // Î≥µÍµ¨Îêú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îã§Ïãú ÌôïÏù∏
            try {
              final recoveredUser = await wepinCubit.state.wepinWidgetSDK!.login.getCurrentWepinUser();
              if (recoveredUser != null && recoveredUser.userInfo != null) {
                '‚úÖ Î≥µÍµ¨Îêú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï†ÄÏû•: ${recoveredUser.userInfo!.email}'.log();
                
                final prefs = await SharedPreferences.getInstance();
                await prefs.setBool('wepin_logged_in', true);
                await prefs.setString('wepin_user_email', recoveredUser.userInfo!.email);
                await prefs.setString('wepin_user_provider', recoveredUser.userInfo!.provider ?? '');
              }
            } catch (userCheckError) {
              '‚ö†Ô∏è Î≥µÍµ¨ ÌõÑ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÌôïÏù∏ Ïã§Ìå®: $userCheckError'.log();
            }
          } else {
            '‚ö†Ô∏è Ïû¨Î°úÍ∑∏Ïù∏ ÌõÑÏóêÎèÑ ÏÉÅÌÉúÍ∞Ä loginÏù¥ ÏïÑÎãò: $recoveredStatus'.log();
          }
        } catch (reloginError) {
          '‚ùå ÏûêÎèô Ïû¨Î°úÍ∑∏Ïù∏ Ïã§Ìå®: $reloginError'.log();
        }
      } else {
        '‚ö†Ô∏è Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏñ¥ ÏûêÎèô Ïû¨Î°úÍ∑∏Ïù∏ Î∂àÍ∞Ä'.log();
      }
      
    } catch (e) {
      '‚ùå ÏÑ∏ÏÖò Î≥µÍµ¨ Ïã§Ìå®: $e'.log();
      await _clearWepinLoginState();
    }
  }

  /// Wepin Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ïÎ¶¨
  Future<void> _clearWepinLoginState() async {
    try {
      'üßπ Wepin Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ïÎ¶¨ Ï§ë...'.log();
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('wepin_logged_in');
      await prefs.remove('wepin_user_email');
      await prefs.remove('wepin_user_provider');
      '‚úÖ Wepin Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ïÎ¶¨ ÏôÑÎ£å'.log();
    } catch (e) {
      '‚ùå Wepin Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ïÎ¶¨ Ïã§Ìå®: $e'.log();
    }
  }

  Future<void> _saveWepinTokensAfterOAuth() async {
    try {
      'üîÑ Attempting to save WePIN OAuth tokens to app storage...'.log();
      
      // Get current Firebase user
      final firebaseUser = FirebaseAuth.instance.currentUser;
      if (firebaseUser == null) {
        '‚ùå No Firebase user found after WePIN OAuth'.log();
        return;
      }
      
      '‚úÖ Firebase user found: ${firebaseUser.uid}'.log();
      
      // Get provider data to determine login type
      final providerData = firebaseUser.providerData;
      String? loginType;
      
      for (final provider in providerData) {
        if (provider.providerId == 'google.com') {
          loginType = 'GOOGLE';
          break;
        } else if (provider.providerId == 'apple.com') {
          loginType = 'APPLE';
          break;
        }
      }
      
      if (loginType == null) {
        '‚ùå Could not determine login type from Firebase user'.log();
        return;
      }
      
      'üîë Login type detected: $loginType'.log();
      
      // Save login type
      final secureStorage = getIt<SecureStorage>();
      await secureStorage.write(StorageValues.socialTokenIsAppleOrGoogle, loginType);
      
      // Get and save tokens based on login type
      if (loginType == 'GOOGLE') {
        // WePIN handles OAuth internally, so we need to use Firebase ID token
        try {
          // First, always save Firebase ID token as it's most reliable
          final firebaseIdToken = await firebaseUser.getIdToken();
          if (firebaseIdToken != null) {
            await secureStorage.write(StorageValues.googleIdToken, firebaseIdToken);
            '‚úÖ Firebase ID token saved for Google login'.log();
          }
          
          // Also try to get Google tokens if available
          try {
            final googleSignIn = GoogleSignIn();
            final googleUser = googleSignIn.currentUser ?? await googleSignIn.signInSilently();
            
            if (googleUser != null) {
              final googleAuth = await googleUser.authentication;
              
              // Save Google access token if available
              if (googleAuth.accessToken != null) {
                await secureStorage.write(StorageValues.googleAccessToken, googleAuth.accessToken!);
                '‚úÖ Google access token also saved'.log();
              }
              
              // If we get a Google ID token, update it (prefer this over Firebase token)
              if (googleAuth.idToken != null) {
                await secureStorage.write(StorageValues.googleIdToken, googleAuth.idToken!);
                '‚úÖ Google ID token updated with native token'.log();
              }
            } else {
              '‚ö†Ô∏è GoogleSignIn session not available (normal for WePIN OAuth)'.log();
            }
          } catch (googleError) {
            '‚ö†Ô∏è Could not get native Google tokens (expected with WePIN): $googleError'.log();
          }
        } catch (e) {
          '‚ùå Error saving tokens: $e'.log();
        }
      } else if (loginType == 'APPLE') {
        // For Apple, we mainly use Firebase ID token
        try {
          final firebaseIdToken = await firebaseUser.getIdToken();
          if (firebaseIdToken != null) {
            await secureStorage.write(StorageValues.appleIdToken, firebaseIdToken);
            '‚úÖ Apple ID token (Firebase) saved'.log();
          }
        } catch (e) {
          '‚ùå Error saving Apple token: $e'.log();
        }
      }
      
      '‚úÖ Token saving process completed'.log();
    } catch (e) {
      '‚ùå Error in _saveWepinTokensAfterOAuth: $e'.log();
    }
  }

  void _goToPreviousPage() {
    // Prevent going back if confirming
    if (_isConfirming) {
      '‚ö†Ô∏è Ï≤òÎ¶¨ Ï§ë - Îí§Î°ú Í∞ÄÍ∏∞ Ï∞®Îã®'.log();
      return;
    }

    if (currentSlideIndex > 0) {
      '‚¨ÖÔ∏è Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô: ${currentSlideIndex} -> ${currentSlideIndex - 1}'.log();
      _moveToPage(currentSlideIndex - 1);
    }
  }

  String _getButtonText() {
    switch (currentSlideIndex) {
      case 0:
        return LocaleKeys.onboarding_understood.tr();  // Ï≤´ Î≤àÏß∏ ÌôîÎ©¥ (ÌïòÎØ∏Ìîå ÏÑ∏Í≥Ñ ÏÜåÍ∞ú)
      case 1:
        return _hasExistingWallet
            ? LocaleKeys.onboarding_confirmed.tr()  // ÏßÄÍ∞ë ÏûàÏùå ÌôîÎ©¥
            : LocaleKeys.onboarding_create_wallet.tr();  // ÏßÄÍ∞ë ÏÜåÍ∞ú
      case 2:
        return _hasExistingProfile
            ? LocaleKeys.onboarding_confirmed.tr()  // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ ÏûàÏùå ÌôîÎ©¥
            : LocaleKeys.onboarding_lets_do_this.tr();  // ÏÑ∏ Î≤àÏß∏ ÌôîÎ©¥ (Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù)
      case 3:
        return LocaleKeys.onboarding_lets_do_this.tr();  // ÎÑ§ Î≤àÏß∏ ÌôîÎ©¥ (ÎãâÎÑ§ÏûÑ ÏûÖÎ†•)
      case 4:
        return LocaleKeys.onboarding_enter_world.tr();  // Îã§ÏÑØ Î≤àÏß∏ ÌôîÎ©¥ (ÏôÑÎ£å)
      default:
        return LocaleKeys.next.tr();
    }
  }

  bool _canProceed() {
    // Disable button on nickname screen if nickname is invalid
    if (currentSlideIndex == 3) {
      return nickname.isNotEmpty && nickname.length >= 2;
    }
    return true;
  }

  String _getLoadingMessage() {
    if (_isCheckingWallet || (currentSlideIndex == 1 && _isConfirming)) {
      return LocaleKeys.onboarding_creating_wallet.tr();
    } else if (currentSlideIndex == 4 && _isConfirming) {
      return LocaleKeys.onboarding_entering_world.tr();
    }
    return LocaleKeys.onboarding_please_wait.tr();
  }

  @override
  void dispose() {
    //sliderTimer.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BaseScaffold(
      backgroundColor: const Color(0xFF87CEEB), // Sky blue background like social auth
      // convert BlocListener to BlocConsumer

      body: MultiBlocListener(
        listeners: [
          // Listen for wallet creation during polling
          BlocListener<WepinCubit, WepinState>(
            bloc: getIt<WepinCubit>(),
            listener: (context, wepinState) {
              // Update wallet checking state
              if (wepinState.isCheckingWallet != _isCheckingWallet) {
                setState(() {
                  _isCheckingWallet = wepinState.isCheckingWallet;
                });
                if (wepinState.isCheckingWallet) {
                  '‚è±Ô∏è Wallet check started - blocking UI'.log();
                } else {
                  '‚úÖ Wallet check completed - unblocking UI'.log();
                }
              }
              
              // Check if wallet was created from onboarding
              // IMPORTANT: Only handle this on the wallet creation page (index 1)
              if (wepinState.walletCreatedFromOnboarding) {
                if (currentSlideIndex == 1) {
                  '‚úÖ Wallet creation from onboarding detected on wallet page!'.log();

                  // Reset the flag to prevent duplicate navigation
                  getIt<WepinCubit>().resetOnboardingWalletFlag();

                  // Move to next page when wallet is created
                  Future.delayed(const Duration(milliseconds: 500), () async {
                    // Double check we're still on the wallet page
                    if (currentSlideIndex == 1) {
                      await _checkUserProfile();
                      if (_hasExistingProfile) {
                        'üÜó Polling ÏôÑÎ£å + ÌîÑÎ°úÌïÑ Ï°¥Ïû¨ - ÌîÑÎ°úÌïÑ ÌôîÎ©¥ÏúºÎ°ú'.log();
                        _moveToPage(2); // Show profile exists page
                      } else {
                        'üÜï Polling ÏôÑÎ£å + ÌîÑÎ°úÌïÑ ÏóÜÏùå - Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉùÏúºÎ°ú'.log();
                        _moveToPage(2); // Move to character selection
                      }
                    } else {
                      '‚ö†Ô∏è Page changed during wallet creation, skipping navigation'.log();
                    }
                  });
                } else {
                  '‚ö†Ô∏è walletCreatedFromOnboarding flag detected on wrong page (${currentSlideIndex}), resetting'.log();
                  // Reset the flag if we're on the wrong page
                  getIt<WepinCubit>().resetOnboardingWalletFlag();
                }
              }
            },
          ),
          BlocListener<EnableLocationCubit, EnableLocationState>(
            bloc: getIt<EnableLocationCubit>(),
            listener: (context, state) async {
          if (state.submitStatus == RequestStatus.success) {
            // Ïò®Î≥¥Îî© ÏôÑÎ£å Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            await _updateOnboardingCompletedStatus();
            
            Navigator.pushNamedAndRemoveUntil(
              context,
              Routes.startUpScreen,
              (route) => false,
            );
          }

          if ((state.submitStatus == RequestStatus.failure) &&
              state.isLocationDenied) {
            // ÏúÑÏπò Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏñ¥ÎèÑ Ïò®Î≥¥Îî© ÏôÑÎ£åÎ°ú Ï≤òÎ¶¨
            await _updateOnboardingCompletedStatus();
            
            Navigator.pushNamedAndRemoveUntil(
              context,
              Routes.startUpScreen,
              (route) => false,
            );
          }
            },
          ),
        ],
        child: Stack(
          children: [
              Column(
                children: <Widget>[
                  const SizedBox(height: 10),
                  // Custom progress indicator
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 20.0),
                    child: Row(
                      children: List.generate(5, (index) {
                        return Expanded(
                          child: Container(
                            margin: EdgeInsets.only(right: index < 4 ? 8 : 0),
                            height: 8,
                            decoration: BoxDecoration(
                              color: index <= currentSlideIndex
                                  ? hmpBlue
                                  : Colors.white.withOpacity(0.3),
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(
                                color: Colors.black,
                                width: 1,
                              ),
                            ),
                          ),
                        );
                      }),
                    ),
                  ),
                  const SizedBox(height: 10),
                  Expanded(
                    child: IndexedStack(
                      index: currentSlideIndex,
                      children: <Widget>[
                        const OnboardingPageSecond(), // 1. ÌïòÎØ∏Ìîå ÏÑ∏Í≥Ñ ÏÜåÍ∞ú
                        _hasExistingWallet 
                            ? const OnboardingPageWalletExists()  // 2. ÏßÄÍ∞ë ÏûàÏùå ÌôîÎ©¥
                            : const OnboardingPageFirst(),        // 2. ÏßÄÍ∞ë ÏÜåÍ∞ú
                        _hasExistingProfile
                            ? OnboardingPageProfileExists(  // 3. ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ ÏûàÏùå ÌôîÎ©¥
                                userProfile: getIt<ProfileCubit>().state.userProfileEntity,
                              )
                            : OnboardingPageThird(                 // 3. Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù (1/10 ~ 10/10 Î≥ÄÍ≤Ω Í∞ÄÎä•)
                                onProfileSelected: (profile) {
                                  setState(() {
                                    selectedProfile = profile;
                                  });
                                },
                                onCharacterSelected: (character) {
                                  setState(() {
                                    selectedCharacter = character;
                                  });
                                },
                              ),
                        OnboardingPageFourth(          // 4. ÎãâÎÑ§ÏûÑ ÏûÖÎ†•
                          selectedProfile: _hasExistingProfile
                              ? (getIt<ProfileCubit>().state.userProfileEntity?.profilePartsString ?? selectedProfile)
                              : selectedProfile,
                          selectedCharacter: _hasExistingProfile
                              ? null  // Use existing profile parts
                              : selectedCharacter,
                          userProfile: _hasExistingProfile
                              ? getIt<ProfileCubit>().state.userProfileEntity
                              : null,
                          onNicknameChanged: (name) {
                            setState(() {
                              nickname = name;
                            });
                          },
                        ),
                        OnboardingPageFifth(           // 5. ÏôÑÎ£å Ï∂ïÌïò
                          selectedProfile: _hasExistingProfile
                              ? (getIt<ProfileCubit>().state.userProfileEntity?.profilePartsString ?? selectedProfile)
                              : selectedProfile,
                          selectedCharacter: _hasExistingProfile
                              ? null  // Use existing profile parts
                              : selectedCharacter,
                          nickname: _hasExistingNickname
                              ? (getIt<ProfileCubit>().state.userProfileEntity?.nickName ?? nickname)
                              : nickname,
                          userProfile: _hasExistingProfile
                              ? getIt<ProfileCubit>().state.userProfileEntity
                              : null,
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 15),
                  currentSlideIndex == 0 || currentSlideIndex == 1
                      ? Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 60.0),
                          child: GradientButton(
                                  text: _getButtonText(),
                                  onPressed: (_isCheckingWallet || _isConfirming)
                                      ? () {} // Disable button when processing
                                      : (currentSlideIndex == 1 && !_hasExistingWallet
                                          ? _createWepinWallet
                                          : _goToNextPage),
                                ),
                        )
                      : Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 60.0),
                          child: currentSlideIndex + 1 == 5
                              ? GradientButton(
                                  text: LocaleKeys.onboarding_enter_world.tr(),
                                  onPressed: _isConfirming
                                            ? () {}
                                            : () async {
                                                // Prevent multiple clicks
                                                if (_isConfirming) {
                                                  '‚ö†Ô∏è Ïù¥ÎØ∏ Ï≤òÎ¶¨ Ï§ë - Ï§ëÎ≥µ ÌÅ¥Î¶≠ Î∞©ÏßÄ'.log();
                                                  return;
                                                }

                                                setState(
                                                    () => _isConfirming = true);

                                                'üöÄ Ïò®Î≥¥Îî© ÏôÑÎ£å Î≤ÑÌäº ÌÅ¥Î¶≠'.log();

                                                // Clear saved step immediately to prevent navigation issues
                                                try {
                                                  final prefs = await SharedPreferences.getInstance();
                                                  await prefs.remove(StorageValues.onboardingCurrentStep);
                                                  'üóëÔ∏è Ï†ÄÏû•Îêú Ïò®Î≥¥Îî© Îã®Í≥Ñ Ï¶âÏãú ÏÇ≠Ï†ú'.log();
                                                } catch (e) {
                                                  '‚ùå Failed to clear saved step: $e'.log();
                                                }

                                                // Check if user already has VALID profile image (not just URL)
                                                final userProfile = getIt<ProfileCubit>().state.userProfileEntity;
                                                bool hasValidProfileImage = false;

                                                // Validate finalProfileImageUrl if it exists
                                                if (userProfile?.finalProfileImageUrl?.isNotEmpty ?? false) {
                                                  'üîç Validating finalProfileImageUrl...'.log();
                                                  final isValid = await _validateImageUrl(userProfile!.finalProfileImageUrl!);
                                                  if (isValid) {
                                                    hasValidProfileImage = true;
                                                    '‚úÖ finalProfileImageUrl is valid'.log();
                                                  } else {
                                                    '‚ö†Ô∏è finalProfileImageUrl exists but image is not valid'.log();
                                                  }
                                                }

                                                // If no valid finalProfileImageUrl, check pfpImageUrl
                                                if (!hasValidProfileImage && (userProfile?.pfpImageUrl?.isNotEmpty ?? false)) {
                                                  'üîç Validating pfpImageUrl...'.log();
                                                  final isValid = await _validateImageUrl(userProfile!.pfpImageUrl!);
                                                  if (isValid) {
                                                    hasValidProfileImage = true;
                                                    '‚úÖ pfpImageUrl is valid'.log();
                                                  } else {
                                                    '‚ö†Ô∏è pfpImageUrl exists but image is not valid'.log();
                                                  }
                                                }

                                                // Determine what needs to be updated
                                                String? nicknameToUpdate = _hasExistingNickname ? null : nickname;
                                                // Don't update profileParts if user already has a VALID profile image
                                                String? profilePartsToUpdate = hasValidProfileImage ? null : selectedCharacter?.toJsonString();

                                                'üìä ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöî Ïó¨Î∂Ä ÌôïÏù∏'.log();
                                                '  - Ïú†Ìö®Ìïú ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ: ${hasValidProfileImage ? "ÏûàÏùå" : "ÏóÜÏùå"}'.log();
                                                if (userProfile != null) {
                                                  '    - finalProfileImageUrl: ${userProfile.finalProfileImageUrl ?? "ÏóÜÏùå"}'.log();
                                                  '    - pfpImageUrl: ${userProfile.pfpImageUrl ?? "ÏóÜÏùå"}'.log();
                                                }
                                                '  - ÎãâÎÑ§ÏûÑ ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöî: ${nicknameToUpdate != null} ${nicknameToUpdate != null ? "($nicknameToUpdate)" : "(Í∏∞Ï°¥ Ïú†ÏßÄ)"}'.log();
                                                '  - ÌîÑÎ°úÌïÑ ÌååÏ∏† ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöî: ${profilePartsToUpdate != null} ${profilePartsToUpdate != null ? "(ÏÉà Ï∫êÎ¶≠ÌÑ∞)" : "(Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ Ïú†ÏßÄ)"}'.log();

                                                // Only update if there's something new to update
                                                if (nicknameToUpdate != null || profilePartsToUpdate != null) {
                                                  'üöÄ ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë'.log();

                                                  try {
                                                    final profileCubit = getIt<ProfileCubit>();

                                                    // Create update profile request with only necessary fields
                                                    final updateRequest = UpdateProfileRequestDto(
                                                      nickName: nicknameToUpdate,
                                                      profilePartsString: profilePartsToUpdate,
                                                    );

                                                    // Update profile
                                                    await profileCubit.onUpdateUserProfile(updateRequest);
                                                    '‚úÖ ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ'.log();

                                                    // Save profile parts string locally if new character was created
                                                    if (profilePartsToUpdate != null && selectedCharacter != null) {
                                                      final prefs = await SharedPreferences.getInstance();
                                                      await prefs.setString('profilePartsString', profilePartsToUpdate);
                                                      'üíæ ÏÉà ÌîÑÎ°úÌïÑ ÌååÏ∏† Î°úÏª¨ Ï†ÄÏû• ÏôÑÎ£å'.log();
                                                    }

                                                    // Start background task for image merging and NFT minting (only for new profiles without valid existing image)
                                                    if (!hasValidProfileImage && selectedCharacter != null) {
                                                      _startImageUploadTask(selectedCharacter);
                                                    }
                                                  } catch (e) {
                                                    '‚ùå ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: $e'.log();
                                                  }
                                                } else {
                                                  '‚úÖ Í∏∞Ï°¥ ÌîÑÎ°úÌïÑÍ≥º ÎãâÎÑ§ÏûÑÏù¥ Î™®Îëê ÏûàÏùå - ÏóÖÎç∞Ïù¥Ìä∏ Í±¥ÎÑàÎõ∞Í∏∞'.log();
                                                  'üìù Í∏∞Ï°¥ ÎãâÎÑ§ÏûÑ: ${getIt<ProfileCubit>().state.userProfileEntity?.nickName}'.log();
                                                  'üé® Í∏∞Ï°¥ ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ: ${getIt<ProfileCubit>().state.userProfileEntity?.finalProfileImageUrl}'.log();
                                                }

                                                // Save onboarding completion and clear saved step
                                                final prefs = await SharedPreferences.getInstance();
                                                await prefs.setBool(StorageValues.onboardingCompleted, true);
                                                await prefs.remove(StorageValues.onboardingCurrentStep);
                                                // Save current onboarding version
                                                await prefs.setInt(StorageValues.onboardingVersion, StorageValues.CURRENT_ONBOARDING_VERSION);
                                                'üíæ Saved onboarding version: ${StorageValues.CURRENT_ONBOARDING_VERSION}'.log();
                                                '‚úÖ Ïò®Î≥¥Îî© ÏôÑÎ£å - Ï†ÄÏû•Îêú Îã®Í≥Ñ Ï¥àÍ∏∞Ìôî'.log();

                                                // Give the background task time to start before navigation (if needed)
                                                if ((!hasValidProfileImage && selectedCharacter != null) || !_hasExistingNickname) {
                                                  await Future.delayed(const Duration(milliseconds: 100));
                                                }

                                                // Navigate to app screen with safety checks
                                                if (context.mounted) {
                                                  'üöÄ Navigating to app screen...'.log();
                                                  try {
                                                    // Ensure no lingering states
                                                    setState(() {
                                                      _isConfirming = false;
                                                    });

                                                    await Navigator.pushNamedAndRemoveUntil(
                                                      context,
                                                      Routes.appScreen,
                                                      (route) => false,
                                                    );
                                                    '‚úÖ Successfully navigated to app screen'.log();
                                                  } catch (e) {
                                                    '‚ùå Navigation failed: $e'.log();
                                                    // Try alternative navigation if first attempt fails
                                                    if (context.mounted) {
                                                      Navigator.of(context).pushReplacementNamed(Routes.appScreen);
                                                    }
                                                  }
                                                } else {
                                                  '‚ùå Context not mounted, cannot navigate'.log();
                                                }
                                              },
                                )
                              : Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 60.0),
                                  child: GradientButton(
                                    text: _getButtonText(),
                                    onPressed: _canProceed() ? _goToNextPage : () {},
                                  ),
                                ),
                        ),
                  SafeArea(
                    top: false,
                    child: SizedBox(
                      height: 30,
                    ),
                  ),
                ],
              ),
              // Loading overlay when checking wallet or processing
              if (_isCheckingWallet || (_isConfirming && (currentSlideIndex == 1 || currentSlideIndex == 4)))
                Container(
                  color: Colors.black.withValues(alpha: 0.5),
                  child: Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const CircularProgressIndicator(
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                        const SizedBox(height: 20),
                        Text(
                          _getLoadingMessage(),
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 18,
                            fontWeight: FontWeight.w600,
                            fontFamily: 'LINESeedKR',
                          ),
                        ),
                        const SizedBox(height: 10),
                        Text(
                          LocaleKeys.onboarding_please_wait.tr(),
                          style: const TextStyle(
                            color: Colors.white70,
                            fontSize: 14,
                            fontFamily: 'LINESeedKR',
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
            ],
          ),
      ),
    );
  }

  setDontShowAgain(bool isDontShow) async {
    final prefs = await SharedPreferences.getInstance();
    if (isDontShow) {
      await prefs.setInt(isShowOnBoardingView, 1);
    } else {
      await prefs.setInt(isShowOnBoardingView, 0);
    }

    var isShowOnBoarding = prefs.getInt(isShowOnBoardingView);
    ("isShowOnBoarding: $isShowOnBoarding").log();
  }

  /// Start background task to merge character layers and mint NFT
  Future<void> _startImageUploadTask(CharacterProfile? character) async {
    'üöÄ _startImageUploadTask called with character: ${character != null}'.log();

    // Skip if user already has existing profile (no need to mint again)
    if (_hasExistingProfile) {
      '‚ö†Ô∏è User already has existing profile - skipping NFT minting'.log();
      return;
    }

    if (character == null) {
      '‚ö†Ô∏è No character selected for image upload'.log();
      return;
    }

    // Run in background without await to ensure it continues after navigation
    // Using anonymous async function for immediate execution
    () async {
      try {
        'üé® Starting character image merge process'.log();
        'üìù Character ID: ${character.id}'.log();
        'üé® Character layers:'.log();
        '  - Background: ${character.background}'.log();
        '  - Body: ${character.body}'.log();
        '  - Clothes: ${character.clothes}'.log();
        '  - Hair: ${character.hair}'.log();
        '  - Eyes: ${character.eyes}'.log();
        '  - Nose: ${character.nose}'.log();
        if (character.earAccessory != null) {
          '  - Ear Accessory: ${character.earAccessory}'.log();
        }
        
        // Step 1: Merge character layers
        final imageBytes = await CharacterImageService.mergeCharacterLayers(character);
        if (imageBytes == null) {
          '‚ùå Failed to merge character layers'.log();
          return;
        }
        '‚úÖ Successfully merged character layers'.log();
        'üìä Image size: ${imageBytes.length} bytes (${(imageBytes.length / 1024).toStringAsFixed(2)} KB)'.log();
        
        // Step 2: Skip S3 upload (not needed as per user request)
        '‚è≠Ô∏è Skipping S3 upload (using server-side image generation)'.log();
        
        // Step 3: Get profile to ensure it's updated
        final profileCubit = getIt<ProfileCubit>();
        await profileCubit.onGetUserProfile();
        '‚úÖ Profile data refreshed'.log();
        
        // Step 4: Trigger NFT minting with API endpoint
        await _mintProfileNft();

      } catch (e, stackTrace) {
        '‚ùå Error in background image upload task: $e'.log();
        'üìö Stack trace: $stackTrace'.log();
      }
    }(); // Ï¶âÏãú Ïã§Ìñâ
  }
  
  /// Mint profile NFT using server-generated image
  Future<void> _mintProfileNft() async {
    try {
      'üé® Starting profile NFT minting process'.log();
      
      // Get wallet address
      final walletsCubit = getIt<WalletsCubit>();
      await walletsCubit.onGetAllWallets();
      'üíº Connected wallets: ${walletsCubit.state.connectedWallets}'.log();
      
      if (walletsCubit.state.connectedWallets.isEmpty) {
        '‚ùå No wallet found for minting'.log();
        return;
      }
      
      // Get the first Ethereum wallet (provider field contains the network)
      final ethereumWallet = walletsCubit.state.connectedWallets.firstWhere(
        (wallet) => wallet.provider.toLowerCase() == 'ethereum',
        orElse: () => walletsCubit.state.connectedWallets.first,
      );
      
      final walletAddress = ethereumWallet.publicAddress;
      'üíº Using wallet ethereumWallet for minting: $ethereumWallet'.log();
      'üíº Using wallet address for minting: $walletAddress'.log();
      
      // Get user profile for metadata
      final profileCubit = getIt<ProfileCubit>();
      final userProfile = profileCubit.state.userProfileEntity;

      if (userProfile == null) {
        '‚ùå User profile not found'.log();
        return;
      }

      // Check if profile parts already exist (indicating NFT was already minted)
      if (userProfile.profilePartsString != null &&
          userProfile.profilePartsString!.isNotEmpty) {
        '‚ö†Ô∏è Profile parts already exist (${userProfile.profilePartsString}), skipping NFT minting'.log();
        return;
      }

      '‚úÖ No existing profile parts found, proceeding with NFT minting'.log();

      // Construct URLs using server endpoints
      final imageUrl = '${appEnv.apiUrl}public/nft/user/${userProfile.id}/image';
      final metadataUrl = '${appEnv.apiUrl}public/nft/user/${userProfile.id}/metadata';
      'üñºÔ∏è Image URL: $imageUrl'.log();
      'üìù Metadata URL: $metadataUrl'.log();
      
      // Create mint request
      final mintRequest = MintNftRequestDto(
        walletAddress: walletAddress,
        imageUrl: imageUrl,
        metadataUrl: metadataUrl,
      );
      
      // Call minting API
      final nftRepository = getIt<NftRepository>();
      final result = await nftRepository.mintPfpNft(request: mintRequest);
      
      result.fold(
        (error) {
          '‚ùå NFT minting failed: ${error.message}'.log();
        },
        (response) async {
          '‚úÖ NFT minting successful!'.log();
          'üîó Transaction Hash: ${response.transactionHash}'.log();
          'üé® NFT Address: ${response.tokenAddress}'.log();
          'üé® Token ID: ${response.tokenId}'.log();
          '‚õìÔ∏è Chain: ${response.chain}'.log();
          'üìù Message: ${response.message}'.log();
          
          // Save minting status
          final prefs = await SharedPreferences.getInstance();
          await prefs.setBool(StorageValues.hasMintedNft, true);
          await prefs.setString(StorageValues.mintingTransactionId, response.transactionHash);
          'üíæ Minting status saved to storage'.log();
        },
      );
    } catch (e) {
      '‚ùå Error in NFT minting: $e'.log();
      // Non-blocking - user can continue even if minting fails
    }
  }
  
  // Ïò®Î≥¥Îî© ÏôÑÎ£å Ïãú ÏßÄÍ∞ëÍ≥º ÌîÑÎ°úÌïÑ ÌååÏ∏† ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  Future<void> _updateOnboardingCompletedStatus() async {
    try {
      'üìù Updating onboarding completion status...'.log();
      
      // ÏßÄÍ∞ë ÏÉÅÌÉú ÌôïÏù∏ Î∞è Ï†ÄÏû•
      await getIt<WalletsCubit>().onGetAllWallets();
      final hasWallet = getIt<WalletsCubit>().state.connectedWallets.isNotEmpty;
      
      // ÌîÑÎ°úÌïÑ ÏÉÅÌÉú ÌôïÏù∏ Î∞è Ï†ÄÏû•
      await getIt<ProfileCubit>().onGetUserProfile();
      final userProfile = getIt<ProfileCubit>().state.userProfileEntity;
      final hasProfileParts = userProfile?.profilePartsString != null && 
                             userProfile!.profilePartsString!.isNotEmpty;
      
      // SharedPreferencesÏóê ÏÉÅÌÉú Ï†ÄÏû•
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(StorageValues.hasWallet, hasWallet);
      await prefs.setBool(StorageValues.hasProfileParts, hasProfileParts);
      await prefs.setBool(StorageValues.onboardingCompleted, true);
      // Save current onboarding version when updating status
      await prefs.setInt(StorageValues.onboardingVersion, StorageValues.CURRENT_ONBOARDING_VERSION);

      '‚úÖ Onboarding status updated - Wallet: $hasWallet, ProfileParts: $hasProfileParts, Version: ${StorageValues.CURRENT_ONBOARDING_VERSION}'.log();
    } catch (e) {
      '‚ùå Error updating onboarding status: $e'.log();
    }
  }
}
